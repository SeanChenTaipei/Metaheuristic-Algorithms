#!/usr/bin/env python
# coding: utf-8

# In[1]:


import numpy as np
import pandas as pd
from itertools import permutations
from joblib import Parallel, delayed
import multiprocessing
import matplotlib.pyplot as plt


# In[2]:


df = pd.read_csv("distance.csv", index_col = 0, encoding = 'big5')


# ## Hill Climbing

# In[3]:


class HillClimbing():
    '''
    Parameters:
    x: The desired vector, represent the order of cities that are visited, not include the starting point.
    start: The city that the route started from and ended at.
    max_iter: The maximum number of iteration
    mutation: We do the mutation by switching the order in which two cities are visited.
    In each iteration, we calculate the best possible route(i.e. the minimum distance)generated by
    switching the order in which two cities are visited to be the current distance, and if current distance
    is smaller than best distance, we replace the best distance with current distance, and record the corresponding x. 
    '''
    def __init__(self, start = 1, df = df):
        self.num = df.shape[0]
        self.store = df.index.to_list()
        self.start = self.store[start]
        self.store[start], self.store[-1] = self.store[-1], self.store[start]
        af = df.reindex(columns=self.store)
        self.df = af.reindex(self.store)
        self.route = []
        self.alg = "HillClimbing"
    def objective(self, x):
        dis = 0
        dis = dis + self.df.iloc[-1, x[0]] + self.df.iloc[x[-1], -1]
        for index, store in enumerate(x[:-1]):
            dis+=self.df.iloc[store, x[index+1]]
        return dis
    def swap(self, x, order):
        y = x.copy()
        y[order[0]] = x[order[1]]
        y[order[1]] = x[order[0]]
        return y
#     def mutation(self, x):
#         n = len(x)
#         order = np.random.randint(0, n, 2)
#         return self.swap(x, order)
    def findBest(self, x):
        perm = permutations(x, 2)
        best_dis = 1000000
        best_nbd = None
        for pair in perm:
            nbd = self.swap(x, pair)
            dist = self.objective(nbd)
            if dist < best_dis:
                best_dis = dist
                best_nbd = nbd
        return best_dis, best_nbd
    def solve(self, max_iter = 50, x = None):
        ## Recording
        h_dis = []
        #initial guess
        if x is None:
            x = np.random.permutation(self.num - 1)
        besth = [x , self.objective(x)]
        cur_dis, cur_nbd = self.findBest(x)
        ity = 1
        while ity <= max_iter:
            ity+=1
            if cur_dis < besth[1]:
                besth[0] = cur_nbd
                besth[1] = cur_dis
            else:
                break
            h_dis.append(besth[1])
            cur_dis, cur_nbd = self.findBest(besth[0])
#             cur_nbd = self.mutation(x)
            cur_dis = self.objective(cur_nbd)
            print(f"Iteration{ity}------Global: {round(besth[1], 2)}")
        h_dis.extend([besth[1]]*(max_iter - len(h_dis)))
        print(f"Iteration{ity}------Global: {round(besth[1], 2)}")
        self.route.append(self.store[-1])
        for name in besth[0]:
            self.route.append(self.store[name])
        self.route.append(self.store[-1])
        return besth, h_dis


# ## Random Walk

# In[4]:


class RandomWalk():
    '''
    Parameters:
    x: The desired vector, represent the order of cities that are visited, not include the starting point.
    start: The city that the route started from and ended at.
    max_iter: The maximum number of iteration
    mutation: We do the mutation by switching the order in which two cities are visited.
    In each iteration, we calculate the best possible route(i.e. the minimum distance)generated by
    switching the order in which two cities are visited to be the current distance, and if current distance
    is smaller than best distance, we replace the best distance with current distance, and record the corresponding x. 
    '''
    def __init__(self, start, df):
        self.num = df.shape[0]
        self.store = df.index.to_list()
        self.start = self.store[start]
        self.store[start], self.store[-1] = self.store[-1], self.store[start]
        af = df.reindex(columns=self.store)
        self.df = af.reindex(self.store)
        self.route = []
        self.alg = "RandomWalk"
    def objective(self, x):
        dis = 0
        dis = dis + self.df.iloc[-1, x[0]] + self.df.iloc[x[-1], -1]
        for index, store in enumerate(x[:-1]):
            dis+=self.df.iloc[store, x[index+1]]
        return dis
    def swap(self, x, order):
        y = x.copy()
        y[order[0]] = x[order[1]]
        y[order[1]] = x[order[0]]
        return y
    def findBest(self, x):
        perm = permutations(x, 2)
        best_dis = 1000000
        best_nbd = None
        for pair in perm:
            nbd = self.swap(x, pair)
            dist = self.objective(nbd)
            if dist < best_dis:
                best_dis = dist
                best_nbd = nbd
        return best_dis, best_nbd
    def solve(self, max_iter = 500):
        ## Recording
        h_dis = []
        #initial guess
        x = np.random.permutation(self.num - 1)
        besth = [x , self.objective(x)]
        cur_dis, cur_nbd = self.findBest(x)
        ity = 1
        count = 0
        while ity <= max_iter and count<=20:
            ity+=1
            if cur_dis < besth[1]:
                besth[0] = cur_nbd
                besth[1] = cur_dis
            else:
                count+=1
            h_dis.append(besth[1])
            cur_dis, cur_nbd = self.findBest(cur_nbd)
            if ity%10 == 0 or ity == 1:
                print(f"Iteration{ity}------Global: {round(besth[1], 2)}")
        h_dis.extend([besth[1]]*(max_iter - len(h_dis)))
        print(f"Iteration{ity}------Global: {round(besth[1], 2)}")
        self.route.append(self.store[-1])
        for name in besth[0]:
            self.route.append(self.store[name])
        self.route.append(self.store[-1])
        return besth, h_dis


# ## TabuSearch

# In[5]:


class TabuSearch():
    '''
    Parameters:
    x: The desired vector, represent the order of cities that are visited, not include the starting point.
    start: The city that the route started from and ended at.
    max_iter: The maximum number of iteration
    list_size: Max length of tabu list
    mutation: We do the mutation by switching the order in which two cities are visited.
    In each iteration, we calculate the best possible route(i.e. the minimum distance)generated by
    switching the order in which two cities are visited to be the current distance, and if current distance
    is smaller than best distance and the corresponding route is not in tabu list, 
    we replace the best distance with current distance, and record the corresponding x. 
    '''
    def __init__(self, start, df, list_size = 10):
        self.num = df.shape[0]
        self.store = df.index.to_list()
        self.start = self.store[start]
        self.store[start], self.store[-1] = self.store[-1], self.store[start]
        af = df.reindex(columns=self.store)
        self.df = af.reindex(self.store)
        self.size = list_size
        self.route = []
        self.alg = "TabuSearch"
    def objective(self, x):
        dis = 0
        dis = dis + self.df.iloc[-1, x[0]] + self.df.iloc[x[-1], -1]
        for index, store in enumerate(x[:-1]):
            dis+=self.df.iloc[store, x[index+1]]
        return dis
    def swap(self, x, order):
        y = x.copy()
        y[order[0]] = x[order[1]]
        y[order[1]] = x[order[0]]
        return y
    def findBest(self, x, tabulist):
        perm = permutations(x, 2)
        best_dis = 1000000
        best_nbd = None
        for pair in perm:
            nbd = self.swap(x, pair)
            dist = self.objective(nbd)
            if nbd.tolist() in tabulist:
                continue
            if dist < best_dis:
                best_dis = dist
                best_nbd = nbd
        return best_dis, best_nbd
    def solve(self, max_iter = 500):
        ## Recording
        h_dis = []
        #initial guess
        tabulist = []
        x = np.random.permutation(self.num - 1)
        besth = [x , self.objective(x)]
        cur_dis, cur_nbd = self.findBest(x, tabulist)
        ity = 1
        while ity <= max_iter:
            ity+=1
            if cur_dis < besth[1]:
                besth[0] = cur_nbd
                besth[1] = cur_dis
                if len(tabulist)<10:
                    tabulist.append(cur_nbd.tolist())
                else:
                    tabulist.pop(0)
                    tabulist.append(cur_nbd.tolist())
            else:
                break
            h_dis.append(besth[1])
            cur_dis, cur_nbd = self.findBest(besth[0], tabulist)
            if ity%10 == 0 or ity == 1:
                print(f"Iteration{ity}------Global: {round(besth[1], 2)}")
        h_dis.extend([besth[1]]*(max_iter - len(h_dis)))
        print(f"Iteration{ity}------Global: {round(besth[1], 2)}")
        self.route.append(self.store[-1])
        for name in besth[0]:
            self.route.append(self.store[name])
        self.route.append(self.store[-1])
        return besth, h_dis


# ## Simulated Annealing

# In[6]:


class SA():
    '''
    Parameters:
    x: The desired vector, represent the order of cities that are visited, not include the starting point.
    start: The city that the route started from and ended at.
    max iteration: The maximum number of iteration
    Temperature Scheduling: We use lagarithmic scheduling.
    Tstart: The starting temperature, defined to be the mean of total distance of 4 random route.
    mutation: We do the mutation by switching the order in which two cities are visited.
    In each iteration, we calculate the best possible route(i.e. the minimum distance)generated by
    switching the order in which two cities are visited to be the current distance, and if current distance
    is smaller than best distance and the corresponding route is not in tabu list, 
    we replace the best distance with current distance, and record the corresponding x. 
    '''
    def __init__(self, start, df):
        self.num = df.shape[0]
        self.store = df.index.to_list()
        self.start = self.store[start]
        self.store[start], self.store[-1] = self.store[-1], self.store[start]
        af = df.reindex(columns=self.store)
        self.df = af.reindex(self.store)
        self.Tstart = None
        self.route = []
        self.alg = "SA"
    def objective(self, x):
        dis = 0
        dis = dis + self.df.iloc[-1, x[0]] + self.df.iloc[x[-1], -1]
        for index, store in enumerate(x[:-1]):
            dis+=self.df.iloc[store, x[index+1]]
        return dis
    def getTemp(self, t):
        ## Tstart is defined to be the value of objective function of a random route.
        if t==0:
            S = 0
            for i in range(4):
                s = np.random.permutation(self.num - 1)
                S += self.objective(s)
            return S/2
        else:
            return self.Tstart/np.log(t+  0.1)
    def swap(self, x, order):
        y = x.copy()
        y[order[0]] = x[order[1]]
        y[order[1]] = x[order[0]]
        return y
    def findBest(self, x):
        perm = permutations(x, 2)
        best_dis = 1000000
        best_nbd = None
        for pair in perm:
            nbd = self.swap(x, pair)
            dist = self.objective(nbd)
            if dist < best_dis:
                best_dis = dist
                best_nbd = nbd
        return best_dis, best_nbd
    def mutation(self, x):
        n = len(x)
        a = np.random.randint(0, n-2)
        b = np.random.randint(a+1, n)
        y = x.copy()
        y[a:b] = np.flip(x[a:b])
        return y
    def solve(self, max_iter = 100):
        ## Recording
        h_dis = []
        # initialize
        x = np.random.permutation(self.num - 1)
        besth = [x , self.objective(x)]
        cur_x, cur_y = x , self.objective(x)
        self.Tstart = self.getTemp(0)
        T = self.Tstart
        ity = 1
        while ity <= max_iter and T > 0.1:
            new_y, new_x = self.findBest(cur_x)

            dE = new_y - cur_y
            if dE<=0:
                cur_x = new_x
                cur_y = new_y
                if cur_y<besth[1]:
                    besth = [cur_x, cur_y]
                h_dis.append(besth[1])
                ity+=1
            else:
                T = self.getTemp(ity)
                r = np.random.uniform(0,1)
                P = np.exp(-dE/T)
                if r<P:
                    #print(f"Iteration:{ity}; dE>0; Changed!")
                    cur_x = new_x
                    cur_y = new_y
                    h_dis.append(besth[1])
                    ity+=1
            if ity%10 == 0 or ity == 1:
                print(f"Iteration{ity}------Global: {round(besth[1], 2)}")
        print(f"Iteration:{ity}")
        self.route.append(self.store[-1])
        for name in besth[0]:
            self.route.append(self.store[name])
        self.route.append(self.store[-1])
        return besth, h_dis


# ## PSO

# In[7]:


class PSO():
    def __init__(self, start, df, swarm_size=3, w = 0.8, max_velocity = 15):
        '''
        Parameters:
        w: Inertia
        swarm_size: number of particles
        initial velocity = identity mapping
        velocity: Here we define our velocity to be a function composition of a sequence of swap operators.
        
        '''
        self.w = w
        self.w_decay = 0.9
        self.swarm_size = swarm_size
        self.max_velocity = max_velocity
        self.num = df.shape[0]
        self.store = df.index.to_list()
        self.start = self.store[start]
        self.store[start], self.store[-1] = self.store[-1], self.store[start]
        af = df.reindex(columns=self.store)
        self.df = af.reindex(self.store)
        self.route = []
        
        self.velocity = [[] for i in range(swarm_size)]
        self.position = [np.random.permutation(self.num-1) for i in range(self.swarm_size)]
        self.local_best_position = self.position
        self.local_best = list(map(self.objective, self.position))
        self.global_best = np.min(self.local_best)
        self.global_best_position = self.local_best_position[np.argmin(self.local_best)]
        self.alg = "PSO"
    def objective(self, x):
        dis = 0
        dis = dis + self.df.iloc[-1, x[0]] + self.df.iloc[x[-1], -1]
        for index, store in enumerate(x[:-1]):
            dis+=self.df.iloc[store, x[index+1]]
        return dis
    def swap(self, x, order):
        y = x.copy()
        y[order[0]] = x[order[1]]
        y[order[1]] = x[order[0]]
        return y
    def swap_seq(self, x, seq):
        y = x.copy()
        for s in seq:
            y[s[0]], y[s[1]] = y[s[1]], y[s[0]]
        return y
    def dsum(self, *seq):
        a = []
        for i in seq:
            a+=i
        return a
    def minus(self, x, y):
        seq = []
        y = y.tolist()
        for index, elt in enumerate(x):
            j = y.index(elt)
            if index != j:
                seq.append([index, j])
        return seq
    def vel(self):
        for i in range(self.swarm_size):
            for item in self.velocity[i]:
                r = np.random.uniform(0,1)
                if r<self.w:
                    self.velocity[i].remove(item)
            r1, r2 = 0.3, 0.5 #np.random.uniform(0,1,2)
            par = self.minus(self.local_best_position[i], self.position[i])
            gbl = self.minus(self.global_best_position, self.position[i])
            for item in par:
                alpha = np.random.uniform(0,1)
                if alpha < r1:
                    self.velocity[i].append(item)
#                     if item in self.velocity[i]:
#                         self.velocity[i].remove(item)
#                     else:
#                         self.velocity[i].append(item)
            for item in gbl:
                beta = np.random.uniform(0,1)
                if beta < r2:
                    if item in self.velocity[i]:
                        self.velocity[i].remove(item)
                    else:
                        self.velocity[i].append(item)
            if len(self.velocity[i])>self.max_velocity:
                self.velocity[i] = self.velocity[i][-self.max_velocity:]
    def update(self):
        self.vel()
        for t in range(self.swarm_size):
            for order in self.velocity[t]:
                self.position[t] = self.swap(self.position[t], order)
    def solve(self, k):
        dis_record = []
        for tt in range(k):
            self.update()
            current_value = list(map(self.objective, self.position))
            current_best = np.min(current_value)
            if current_best < self.global_best:
                self.global_best = current_best
                self.global_best_position = self.position[np.argmin(current_value)]
                self.count = 0
            for index, value in enumerate(current_value):
                if value < self.local_best[index]:
                    self.local_best[index] = value
                    self.local_best_position[index] = self.position[index]
            if self.w>0.1:
                self.w = self.w_decay*self.w
            dis_record.append(self.global_best)
            if tt%10 == 0 or tt == 1:
                print(f"Iteration{tt}------Global: {round(self.global_best, 2)}--Local: {round(current_best, 2)}")
        self.route.append(self.store[-1])
        for name in self.global_best_position:
            self.route.append(self.store[name])
        self.route.append(self.store[-1])
        return [self.global_best_position, self.global_best], dis_record


# ## Genetic Algorithm

# In[8]:


class GA():
    def __init__(self, start, df, population_size, selection_rate = 0.5, select_by_prob = False):
        self.num = df.shape[0]
        self.size = population_size
        self.rate = selection_rate
        self.store = df.index.to_list()
        self.start = self.store[start]
        self.prob = select_by_prob
        self.store[start], self.store[-1] = self.store[-1], self.store[start]
        af = df.reindex(columns=self.store)
        self.df = af.reindex(self.store)
        self.df = self.df.to_numpy()
        
        self.population = np.array([np.random.permutation(self.num-1) for i in range(self.size)])
        self.value = np.array(list(map(self.objective, self.population)))
        self.best_value = np.min(self.value)
        self.best_value_position = self.population[np.where(self.value==self.best_value)[0]]
        self.route = []
        self.alg = "GA"
    def objective(self, x):
        y = x.tolist()
        y.insert(0, self.num-1)
        y.append(self.num-1)
        return self.df[y[:-1], y[1:]].sum()
    def fitness(self, values):
        total = values.sum()
        n = len(values)
        prob = (1-values/total)/(n-1)
        return prob
    def selection(self):
        rate = self.rate
        num_of_sel = int(self.size*rate)
        if num_of_sel%2!=0:
            num_of_sel = num_of_sel+1
        if self.prob==True:
            probability = self.fitness(self.value)
            index = np.random.choice(self.size, num_of_sel, p = probability, replace = False)
            candidates = self.population[index]
        else:
            candidates = self.population[np.argsort(self.value)[:num_of_sel]]
        return candidates
    def twodotcrossover(self, p1, p2):
        n = len(p1)
        a = np.random.randint(0 , n-15)
        b = a + 11
        c1 = p2[a:b]
        c2 = p1[a:b]
        o1 = np.setdiff1d(p1, c2)
        o2 = np.setdiff1d(p2, c1)
        o1 = np.insert(o1, a, c2)
        o2 = np.insert(o2, a, c1)
        o1 = self.mutation(o1, method = 0)
        o2 = self.mutation(o2, method = 0)
        return o1, o2
    def mutation(self, x, method=-1):
        n = len(x)
        if method==-1:
            y = x.copy()
            for pm in range(3):
                u = np.random.uniform(0, 1)
                if u<0.8:
                    a = np.random.randint(0, n-2)
                    y[a:a+3] = np.flip(y[a:a+3])
                else:
                    pass
        else:
            y = x.copy()
            for pm in range(20):
                u = np.random.uniform(0, 1)
                if u<0.5:
                    order = np.random.choice(n, 2, replace=False)
                    y[order[0]], y[order[1]] = y[order[1]], y[order[0]]
                else:
                    pass
        return y
    def crossover(self, parents):
        n = len(parents)
        np.random.shuffle(parents)
        childs = []
        for p in range(int(n/2)):
            p1 = parents[p]
            p2 = parents[p+1]
            o1, o2 = self.twodotcrossover(p1, p2)
            childs.append(o1)
            childs.append(o2)
        return np.array(childs)
    def newgeneration(self, prob = False):
        candidates = self.selection()
        offsprings = self.crossover(parents = candidates)
        value_offsprings = np.array(list(map(self.objective, offsprings)))
        values = np.hstack([self.value, value_offsprings])
        nums = len(offsprings) + self.size
        if self.prob==True:
            prob = self.fitness(values)
            index = np.random.choice(nums, self.size, p = prob, replace = False)
            newgen = np.vstack([self.population, offsprings])[index]
            newvalues = values[index]
        else:
            index = np.argsort(values)[:self.size]
            newgen = np.vstack([self.population, offsprings])[index]
            newvalues = values[index]
        return newgen, newvalues
    def solve(self, generations = 50):
        dis_record = []
        for g in range(generations):
            self.population, self.value = self.newgeneration()
            local_best_value = np.min(self.value)
            if local_best_value < self.best_value:
                self.best_value = local_best_value
                self.best_value_position = self.population[np.where(self.value==local_best_value)[0]]
            if g%20==0:print(f"generation:{g}, best:{round(self.best_value, 2)}")
            dis_record.append(self.best_value)
        self.route.append(self.store[-1])
        for name in self.best_value_position[0]:
            self.route.append(self.store[name])
        self.route.append(self.store[-1])
        return [self.best_value_position[0], self.best_value], dis_record


# ## ACO

# In[9]:


class ACO():
    def __init__(self, start, df, best_ants = 0.3, evaporation_rate = 0.5, alpha = 1.0, beta = 1.0, swarm_size = 100):
        self.num = df.shape[0]
        self.store = df.index.to_list()
        self.start = self.store[start]
        self.store[start], self.store[-1] = self.store[-1], self.store[start]
        af = df.reindex(columns=self.store)
        self.df = af.reindex(self.store).to_numpy()
        self.start_store = df.index[start]
        self.store_list = df.index
        self.route = []
        self.alg = "ACO"
        
        self.size = swarm_size
        self.alpha = alpha
        self.beta = beta
        self.evaporation_rate = evaporation_rate
        self.intensify_constant = 1
        self.best_ant_bonus = 5
        self.leaving_pheromone = int(best_ants*self.size)
        
        self.pheromone = np.ones(df.shape) - np.eye(self.num)
        a = 1/self.df
        np.fill_diagonal(a, 0)
        self.dis_inverse = a**self.beta
        self.probability_matrix = ((self.pheromone**self.alpha) * self.dis_inverse)
        self.path_by_ants = []
        self.best_path = None
        self.best_dis = 10000000000
        
        
    def objective(self, x):
        y = x.copy()
        y.insert(0, self.num-1)
        y.append(self.num-1)
        return self.df[y[:-1], y[1:]].sum()
    def evaporation(self):
        self.pheromone = self.pheromone*(1 - self.evaporation_rate)
    def intensify(self, path, i):
        p = path.copy()
        p.insert(0, self.num-1)
        p.append(self.num-1)
        self.pheromone[p[:-1], p[1:]] = self.pheromone[p[:-1], p[1:]] + self.intensify_constant*i ###changed here
    def update_probabilty(self):
        self.probability_matrix = (self.pheromone**self.alpha) * self.dis_inverse
    def _next_node(self, current, choices):
        n = len(choices)
        if n == 1:
            return choices[0]
        numerator = self.probability_matrix[current, choices]
        if numerator.max()<1e-12:
            prob = np.ones(n)/n
        else:
            denominator = numerator.sum()
            prob = numerator/denominator
        next_index = np.random.choice(n, p = prob)
        return choices[next_index]
    def solve(self, max_iter = 20):
        dis_record = []
        for it in range(1, max_iter+1):
            self.path_by_ants = []
            for ant in range(self.size):
                path_individual = []
                current_node = -1
                nodes_available = [i for i in range(35)]
                while nodes_available != []:
                    next_node = self._next_node(current_node, nodes_available)
                    path_individual.append(next_node)
                    nodes_available.remove(next_node)
                self.path_by_ants.append(path_individual)
            values = list(map(self.objective, self.path_by_ants))
            if self.leaving_pheromone == self.size:
                min_index = [i for i in range(self.size)]
            else:
                min_index = np.argpartition(values, self.leaving_pheromone)[:self.leaving_pheromone]
            local_best_path = self.path_by_ants[min_index[0]]
            local_best_value = values[min_index[0]]
            worst = np.argmax(values)
            local_worst_path = self.path_by_ants[worst]
            local_worst_value = values[worst]
            self.evaporation()
            for k, index in enumerate(min_index):
                self.intensify(self.path_by_ants[index], local_worst_value/local_best_value)
            if self.best_path:
                self.intensify(self.best_path, self.best_ant_bonus)
            self.update_probabilty()
            
            if local_best_value < self.best_dis:
                self.best_dis = local_best_value
                self.best_path = local_best_path
            if it%10==0 or it == 1:
                if self.leaving_pheromone>5:
                    self.leaving_pheromone = int(0.9*self.leaving_pheromone)

                print(f"Iteration{it}------Global: {round(self.best_dis, 2)}--Local: {round(local_best_value, 2)}")
#                 print(f"Shortest path: \n{local_best_path}")
#                 print(f"Itensity: {local_worst_value/local_best_value}")
            self.beta = 0.0
            a = 1/self.df
            np.fill_diagonal(a, 0)
            self.dis_inverse = a**self.beta
            dis_record.append(self.best_dis)
        self.route.append(self.store[-1])
        for name in self.best_path:
            self.route.append(self.store[name])
        self.route.append(self.store[-1])
        return [self.best_path, self.best_dis], dis_record


# ## Iterated_Local_Search

# In[10]:


class Iterated_Local_Search(HillClimbing):
    '''
    Modify the HillClimbing by iterated local search 
    '''
    def __init__(self, start, df, n_restarts = 3):
        super(Iterated_Local_Search, self).__init__(start, df)
        self.restart = n_restarts
        self.alg = "IteratedLocalSearch"
    def perturbation(self, x):
        n = len(x)
        y = x.copy()
        pts = np.random.choice(n-5, 3, replace = False)
        for a in pts:
            y[a:a+3] = np.flip(x[a:a+3])
        return y
    def iterated_local_search(self):
        dis = []
        started = np.random.permutation(self.num - 1)
        besth = [started , self.objective(started)]
        for i in range(self.restart):
            started = self.perturbation(besth[0])
            best_sol, dis_i = self.solve(max_iter = 10, x = started)
            if best_sol[1] < besth[1]:
                besth = best_sol
            dis.extend(dis_i)
        return besth, dis


# In[11]:


# ILS = Iterated_Local_Search(start = 1, df = df, n_restarts=5)


# In[12]:


# ILS.iterated_local_search()


# In[13]:


###Solvers
# hc = HillClimbing(start = 1, df = df)
# rw = RandomWalk(start = 1, df = df)
# ts = TabuSearch(start = 1, df = df, list_size = 10)
# pso = PSO(start = 1, df = df, max_velocity = 15, swarm_size=800)
# sa = SA(start = 1, df = df)
# ga = GA(start = 1, df = df, selection_rate=0.6, population_size=800, select_by_prob=True)
# aco = ACO(start = 1, df = df, alpha = 1.0, beta = 1.0, best_ants = 0.6, evaporation_rate = 0.1, swarm_size = 800)
# ICL = Iterated_Local_Search(start = 1, df = df, n_restarts=5)


# In[14]:


# solver_list = [hc, rw, ts, pso, sa, ga, aco]


# In[15]:


# dic = {}
# plt.figure(figsize = (10,6))
# plt.title("FE plot", fontsize = 15)
# plt.ylabel("Best Value", fontsize = 15)
# plt.xlabel("Iteration", fontsize = 15)
# plt.ylim(20, 90)
# iteration = 200
# for solver in solver_list:
#     print(f"---{solver.alg}---")
#     best, dis = solver.solve(iteration)
#     dic[solver.alg] = dis[-iteration:]
#     plt.plot(dis[-iteration:], label = solver.alg)
# plt.legend()


# In[16]:


# result_df = pd.DataFrame(dic)


# In[17]:


# result_df

